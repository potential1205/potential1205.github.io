<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | 파브르의 개발 블로그</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://potential1205.github.io/categories/java/><link crossorigin=anonymous href=/assets/css/stylesheet.f02ab5e1c7ddcfc737103d1fe18b7d8813856b4be4a376e5db84a46081486c77.css integrity="sha256-8Cq14cfdz8c3ED0f4Yt9iBOFa0vko3bl24SkYIFIbHc=" rel="preload stylesheet" as=style><link rel=icon href=https://potential1205.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://potential1205.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://potential1205.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://potential1205.github.io/apple-touch-icon.png><link rel=mask-icon href=https://potential1205.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://potential1205.github.io/categories/java/index.xml title=rss><link rel=alternate hreflang=en href=https://potential1205.github.io/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://potential1205.github.io/categories/java/"><meta property="og:site_name" content="파브르의 개발 블로그"><meta property="og:title" content="Java"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content></head><body class=list id=top><header class="header site-header"><nav class=header__nav><div class=header__left><a class=header__brand-link href=/ accesskey=h title="파브르의 개발 블로그 (Alt + H)"><span class=header__brand-avatar><img src=https://potential1205.github.io/profile-img.png alt="파브르의 개발 블로그" loading=lazy></span><span class=header__brand-text>파브르의 개발 블로그</span></a></div><div class=header__center><form class=header-search action=/posts/ method=get role=search><label class=sr-only for=header-search>Search</label>
<input id=header-search type=search name=q placeholder=검색 aria-label=Search>
<button type=submit class=header-search__submit aria-label=Search>
<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></button></form></div><div class=header__right><a class=header__icon href=https://github.com/potential1205 target=_blank rel=noopener aria-label=GitHub><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 .5A12 12 0 008.21 23.9c.6.11.82-.26.82-.58l-.02-2.02c-3.34.73-4.04-1.61-4.04-1.61-.55-1.4-1.34-1.77-1.34-1.77-1.09-.74.08-.73.08-.73 1.2.08 1.83 1.23 1.83 1.23 1.07 1.83 2.8 1.3 3.48.99.11-.78.42-1.3.76-1.6-2.67-.3-5.47-1.33-5.47-5.9.0-1.3.46-2.36 1.22-3.19-.12-.3-.53-1.5.12-3.13.0.0 1-.32 3.3 1.22a11.5 11.5.0 016 0c2.3-1.54 3.29-1.22 3.29-1.22.66 1.63.25 2.83.12 3.13.76.83 1.21 1.89 1.21 3.2.0 4.59-2.8 5.59-5.48 5.88.43.37.81 1.1.81 2.22l-.01 3.29c0 .32.21.7.82.58A12 12 0 0012 .5z"/></svg>
</a><a class=header__icon href=https://www.linkedin.com target=_blank rel=noopener aria-label=LinkedIn><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M4.98 3.5a2.5 2.5.0 110 5 2.5 2.5.0 010-5zM3 8.98h3.96V21H3V8.98zm7.03.0H14v1.64h.05c.42-.8 1.45-1.64 2.98-1.64 3.19.0 3.78 2.1 3.78 4.84V21h-3.96v-5.22c0-1.24-.02-2.84-1.73-2.84-1.73.0-1.99 1.35-1.99 2.75V21H10V8.98z"/></svg>
</a><a class="header__icon header__icon--rss" href=/index.xml aria-label="RSS feed" title=RSS><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18a2 2 0 11-4 0 2 2 0 014 0zM2 4.5v3A14.5 14.5.0 0116.5 22h3C19.5 12.58 11.42 4.5 2 4.5zm0 6v3a8.5 8.5.0 018.5 8.5h3C13.5 14.49 8.01 9 2 10.5z"/></svg>
</a><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></nav></header><main class="main main--with-sidebar"><aside class="main__sidebar main__sidebar--left"><nav class=category-nav aria-label=카테고리><ul class=category-nav__list><li class=category-nav__item data-category=__all><a class=category-nav__link href=/posts/><span class=category-nav__name>전체보기</span>
<span class=category-nav__count>1</span></a></li><li class="category-nav__item is-active" data-category=java><a class=category-nav__link href=/categories/java/ aria-current=page><span class=category-nav__name>Java</span>
<span class=category-nav__count>1</span></a></li></ul></nav></aside><section class=main__content><header class=page-header><h1>Java (1)</h1></header><p id=post-search-empty class=post-search__empty hidden></p><div id=post-list><article class="post-entry tag-entry has-cover" data-search="Java는 어떻게 실행될까 — JVM과 메모리의 동작원리 Java의 특징을 이해하려면 JVM을 빼놓을 수 없다. 코드가 컴파일되고 실행되기까지 어떤 과정을 거치는지, JVM 내부에서 메모리가 어떻게 관리되는지를 간단히 정리해보았다. Java가 선택한 전략 [C: 자유로운 저수준 제어와 개발자의 책임] C는 하드웨어와 가까운 언어 중 하나로, 메모리와 프로세스, 파일 같은 운영체제 자원에 직접 접근할 수 있는 저수준 제어권을 프로그래머에게 제공한다. 이 덕분에 운영체제, 컴파일러, 드라이버 같은 ‘시스템의 뼈대’를 짤 수 있을 만큼 강력하고 효율적인 언어가 되었다. malloc()으로 메모리를 할당하고, 내부적으로 커널의 메모리 관리 시스템 콜을 통해 실제 자원(물리 메모리)을 요청한다. Java의 특징을 이해하려면 JVM을 빼놓을 수 없다. 코드가 컴파일되고 실행되기까지 어떤 과정을 거치는지, JVM 내부에서 메모리가 어떻게 관리되는지를 간단히 정리해보았다. Java가 선택한 전략 [C: 자유로운 저수준 제어와 개발자의 책임] C는 하드웨어와 가까운 언어 중 하나로, 메모리와 프로세스, 파일 같은 운영체제 자원에 직접 접근할 수 있는 저수준 제어권을 프로그래머에게 제공한다. 이 덕분에 운영체제, 컴파일러, 드라이버 같은 ‘시스템의 뼈대’를 짤 수 있을 만큼 강력하고 효율적인 언어가 되었다. malloc()으로 메모리를 할당하고, 내부적으로 커널의 메모리 관리 시스템 콜을 통해 실제 자원(물리 메모리)을 요청한다. 하지만 자원 접근과 제어가 자유로운만큼 잘못된 포인터 접근이나 메모리 누수 같은 문제는 프로그램 전체를 불안정하게 만든다. 즉, C는 프로그래머에게 막강한 권한과 자유를 주는 대신, 그 대가로 안전성에 대한 책임을 전적으로 개발자에게 전가한 언어라 할 수 있다. [Java: 시스템이 개발자를 보호하는 구조] 이런 위험을 언어 차원에서 제어해보자는 시도가 Java의 등장으로 이어졌다. Java는 메모리 관리, 타입 검사, 예외 처리, JVM 기반 실행으로 시스템이 프로그래머를 보호하는 구조로 설계되었다. 프로그래머의 실수로 발생할 수 있는 불안정성과 운영체제 자원 관리의 복잡성을 언어 설계 차원에서 제어하고 성능과 속도보다 안정성과 일관성을 선택했다. C에서 직접 처리해야 했던 메모리 해제, 포인터 접근 검증, 플랫폼별 빌드 차이를 언어와 런타임이 대신 수행하게 함으로써, 프로그래머의 실수로 인한 리스크를 근본적으로 줄였다. JVM: Java의 실행을 가능하게 하는 엔진 [JVM의 역할] 이 모든 메커니즘의 중심에는 JVM(Java Virtual Machine)이 있다. Java 프로그램은 운영체제 위에서 직접 실행되지 않고, JVM이라는 가상머신 위에서 바이트코드(Bytecode) 형태로 동작한다. JVM은 운영체제의 복잡성을 추상화하고, 메모리 관리와 스레드 제어 같은 자원 관리 기능을 대신 수행한다. 즉, 운영체제와 프로그램 사이에서 일관된 실행 환경을 제공하는 핵심 엔진이다. 덕분에 Java는 한 번 작성하면 운영체제나 하드웨어 환경이 달라져도 어디서든 실행될 수 있었고 프로그래머는 메모리 해제나 포인터 오류 같은 저수준 문제에서 해방될 수 있었다. [JVM이 제공하는 주요 이점] 운영체제와 하드웨어로부터의 독립성 Java 코드는 특정 CPU나 OS를 의식하지 않고 “한 번 컴파일, 어디서나 실행(Write Once, Run Anywhere)”을 실현한다. JVM이 OS 호출과 파일 I/O를 내부에서 중개하기 때문이다. 일관된 메모리 모델 OS마다 메모리 관리 방식이 다르지만, JVM은 이를 통일된 방식으로 감싼다. 개발자는 new로 객체를 생성하고, GC가 알아서 회수하는 일관된 흐름만 이해하면 된다. 스레드 및 동기화 관리 OS마다 스레드 스케줄링 정책이 다르지만, JVM은 이를 자체적으로 관리하며 synchronized, volatile, wait/notify 같은 Java 문법으로 동일한 동작을 보장한다. 보안 및 예외 처리 JVM은 클래스 로딩 단계에서부터 접근 제어, 타입 검증, 예외 처리를 담당한다. 즉, 실행 전에 이미 “안전하지 않은 코드”를 차단한다. 이처럼 복잡한 시스템 제어는 JVM에게 맡기면서, 개발자는 그 위에서 ‘무엇을 구현할 것인가’에만 집중할 수 있게 되었다. [JVM, JRE, JDK 차이점] JVM을 살펴보기전 먼저 Java 실행 환경을 구성하는 세 가지 개념을 구분할 필요가 있다. 이들은 포함 관계를 이루며, 단순히 실행만 가능한 환경(JRE)과 개발까지 가능한 환경(JDK)을 구분하는 기준이 된다. JVM(Java Virtual Machine): Java 바이트코드를 읽어 운영체제에 맞는 기계어로 변환하고 실행하는 엔진으로 GC, JIT, ClassLoader 등이 포함됨. JRE(Java Runtime Environment): JVM + 표준 라이브러리(API)로 구성된 실행 환경으로 .class 파일을 실행할 수 있음. JDK(Java Development Kit): JRE + 개발 도구 세트로 Java 애플리케이션을 컴파일, 빌드, 디버그, 문서화할 수 있음. Execution Engine에는 JIT Compiler, Interpreter, Garbage Collector 등이 포함된다. [JVM의 구조와 구성요소] Java 프로그램이 실행되는 순간, JVM 내부에서는 여러 서브시스템이 단계적으로 움직인다. 컴파일된 .class 파일이 단순히 ‘실행’되는 것이 아니라, 로딩 → 검증 → 실행 → 메모리 관리 → 최적화 까지 여러 하위 모듈이 협력해 일련의 과정을 거친다. 즉, JVM은 단순한 실행기가 아니라, 코드의 안전성과 성능을 동시에 보장하는 가상화된 (유사)운영체제라고 볼 수 있다. 주요 구성요소 Class Loader (클래스 로더 시스템) .class 파일을 읽어 JVM 메모리에 로드하고, 필요한 시점에 클래스를 적재한다. 로딩(Loading) → 연결(Linking) → 초기화(Initialization) 단계로 구성된다. 계층적 구조를 가지며 Bootstrap → Extension → Application ClassLoader 순으로 동작한다. Runtime Data Area (실행 시 데이터 저장 영역) JVM이 실행 중에 사용하는 메모리 공간이다. Heap, Stack, PC Register, Metaspace 등으로 구성되어 있으며, GC, 스레드, 객체 할당 모두 이 영역에서 관리된다. JNI (Java Native Interface) Java 코드가 네이티브 라이브러리(C/C++)를 호출할 수 있도록 하는 다리 역할을 한다. 파일 I/O, 그래픽, 네트워크처럼 OS 종속 기능을 사용할 때 활용된다. Execution Engine 내부 구성 요소 바이트코드를 실제로 실행하는 핵심 모듈이다. 내부적으로 다음과 같은 하위 구성요소로 이루어진다. Interpreter: 바이트코드를 순차적으로 해석·실행 JIT Compiler: 반복 실행되는 코드를 네이티브 코드로 변환해 성능 향상 Garbage Collector (GC): 사용되지 않는 객체를 자동으로 회수해 메모리 관리 -&amp;amp;gt; 어플리케이션 성능과 관련있음 [JVM의 동작과정] 컴파일 단계 - javac .java 소스 코드를 플랫폼 독립적인 바이트코드(.class)로 컴파일한다. 이 과정에서 문법 오류, 타입 검증 등 기본적인 정적 검사도 수행한다. 클래스 로딩 단계 - Class Loader 컴파일된 .class 파일을 JVM 메모리에 로드한다. 필요한 클래스만 지연 로딩(Lazy Loading)하며, 중복 로드를 방지하기 위해 이미 로드된 클래스는 캐싱한다. 검증 단계 - Bytecode Verifier 로드된 클래스가 메모리 접근 위반, 스택 언더플로우, 타입 불일치 등 JVM 규칙을 위반하지 않는지 검증한다. 즉, 실행 전에 악성 코드나 비정상 바이트코드 실행을 원천 차단한다. 실행 단계 - Execution Engine 바이트코드를 한 줄씩 해석하거나, 자주 실행되는 코드를 JIT(Just-In-Time) 컴파일로 변환해 네이티브 코드로 변환한다. HotSpot JVM은 실행 빈도를 기반으로 “핫스팟(Hot Spot)” 코드를 감지해 동적으로 컴파일을 수행한다. [JVM의 오버헤드] 물론 JVM이 모든 것을 대신해준다는 건, 그만큼 내부적으로 오버헤드와 복잡한 아키텍처를 감추고 있다는 뜻이다. 즉, Java 애플리케이션은 실제로는 “OS 위의 OS”가 돌아가는 구조다. 이중 구조 덕분에 코드의 안정성과 이식성은 높아졌지만, 시스템 리소스 관점에서 보면 JVM 자체가 거대한 관리 주체로 작동한다. 이로 인해 대표적으로 다음과 같은 오버헤드가 발생한다. 실행 속도 지연 바이트코드가 바로 CPU 명령어로 실행되지 않고, JVM이 해석하거나 JIT(Just-In-Time) 컴파일 과정을 거쳐야 한다. 덕분에 이식성은 얻었지만, C처럼 “즉시 실행”되는 속도는 잃었다. 메모리 사용량 증가 JVM 자체가 하나의 프로세스이기 때문에, 프로그램 코드 외에도 ClassLoader, GC, 메타데이터, JIT 캐시 등 여러 런타임 컴포넌트가 별도의 메모리를 요구한다. 예를 들어, 단순한 “Hello World”조차도 JVM 위에서 수십 MB를 점유한다. 예측하기 어려운 지연 GC는 자동 메모리 관리라는 장점이 있지만, 언제 발생할지 정확히 알 수 없는 Stop-the-World로 인해 실시간 응답이 중요한 시스템에서는 성능 지연으로 이어질 수 있다. Native 접근의 제약 하드웨어와 직접 통신하거나 OS 커널 레벨 제어가 필요한 작업은 JNI(Java Native Interface)를 통해 우회적으로 수행해야 한다. 이는 시스템 호출 비용이 추가되고, 디버깅 난이도도 높인다. 결국 Java의 오버헤드는 안전성과 이식성을 위해 발생한 비용이다. 하지만 현대 JVM은 이 한계를 줄이기 위해 JIT 최적화, Escape Analysis, GC 병렬화 등 다양한 기술로 오버헤드를 최소화하고 있다. (납득가능한 느림) 대부분의 백엔드 CRUD, Batch에서는 미미하지만 초저지연 트레이딩, 게임 서버 틱 루프, 실시간 스트리밍 인코더처럼 p99 지연이 중요한 작업에서는 JVM 관련 설계, 튜닝(스레드 풀/GC/바인딩)이 유의미한 성능 차이를 만든다고 한다. [JVM의 발전과 개선] 20년이 넘는 세월 동안 JVM은 끊임없이 진화하며 단점을 최적화 기술로 상쇄해왔다. 대표적으로 다음과 같은 핵심 기술들이 있다. JIT(Just-In-Time) 컴파일러 자주 실행되는 바이트코드를 동적으로 기계어로 변환하여 성능을 극적으로 개선했다. HotSpot JVM은 이 기술로 C 수준의 속도를 달성했다. Escape Analysis &amp;amp;amp; Inline Optimization 객체가 지역 스코프를 벗어나지 않으면 Heap 대신 Stack에 저장하고, 호출 비용이 큰 메서드는 인라인화하여 함수 호출 오버헤드를 제거한다. 경량화된 JVM (J9, GraalVM, SubstrateVM) 클라우드 네이티브 환경에 맞게 시작 속도, 메모리 사용량을 줄인 JVM들이 등장했다. 특히 GraalVM은 AOT(사전 컴파일)로 실행 파일 수준까지 줄여, 네이티브처럼 빠른 구조로 진화했다. JVM의 메모리 구조 [JVM 메모리 개요] JVM은 실행 중 필요한 데이터를 효율적으로 관리하기 위해 프로그램의 성격에 따라 메모리를 여러 영역으로 나누어 사용한다. 각 영역은 서로 다른 책임을 가지고 있으며, 이 구조 덕분에 Java는 수많은 스레드와 객체가 동시에 동작하더라도 안정적으로 메모리를 제어할 수 있다. 이제 JVM이 실제로 어떤 방식으로 메모리를 구분하고, 각 영역이 어떤 역할을 맡는지 살펴보자. 운영체제의 메모리가 코드, 데이터, 스택, 힙으로 나뉘듯이 JVM도 비슷한 원리를 따르지만, Java의 철학에 맞게 조금 더 정교하게 설계되어 있다. [JVM 메모리 구성] 영역 설명 특징 Heap 객체가 생성되는 영역. GC의 주요 대상 스레드 간 공유 Stack 메서드 호출과 지역 변수 저장. 스레드별 독립 스레드 고유 Metaspace 클래스 메타데이터 저장 (Java 8 이후 OS 메모리 사용) OS가 관리 Code Cache JIT 컴파일된 코드 저장, 실행 성능 향상 내부 최적화 Native Method Stack JNI 호출용 스택 OS 종속 Heap(객체의 생명주기가 시작되는 곳) Java에서 생성된 모든 객체 인스턴스가 저장되는 공간이다. 가비지 컬렉터(GC)가 이 영역을 주기적으로 감시하며, 참조되지 않는 객체를 회수한다. Young Generation(Eden, Survivor)과 Old Generation으로 나뉜다. Young 영역은 새 객체가, Old 영역은 오래 살아남은 객체가 저장된다. 스레드 간에 공유되는 영역이며, GC의 주요 대상이다. Young Generation 새로 생성된 객체가 머무는 공간. Eden → Survivor(S0, S1) → Promotion(Old) 순으로 이동한다. 대부분의 객체는 이 영역에서 곧바로 사라지기 때문에 Minor GC가 자주 일어난다. Old Generation Young 영역에서 여러 번 살아남은 객체가 승격되어 저장되는 곳. 장기 생존 객체, 캐시, 세션 정보 등이 이 영역에 위치하며, GC의 단위가 크고 비용도 높다(Major / Full GC). Stack 각 스레드마다 독립적으로 생성되며, 메서드 호출 시마다 Stack Frame이 쌓이는 구조다. 하나의 Stack Frame에는 지역 변수, 매개변수, 반환 주소, 연산 중간값 등이 저장된다. 메서드 호출이 끝나면 해당 Frame이 사라지고, LIFO(후입선출) 구조로 동작한다. 너무 깊은 재귀 호출은 Stack Overflow로 이어질 수 있다. -Xss 옵션으로 스택 크기를 조정할 수 있다. Metaspace 클래스의 메타데이터(이름, 필드, 메서드 시그니처, 상속 구조 등)가 저장되는 영역이다. Java 8부터 PermGen이 제거되고, OS 메모리를 사용하는 Metaspace로 대체되었다. 클래스 로더에 의해 동적으로 로드된 클래스 정보가 여기에 적재된다. Heap 영역이 아닌 운영체제의 네이티브 메모리를 사용한다. 리플렉션이나 프록시 클래스를 과도하게 생성하면 OutOfMemoryError: Metaspace가 발생할 수 있다. Code Cache JIT(Just-In-Time) 컴파일된 기계어 코드를 저장하는 영역이다. 자주 실행되는 바이트코드를 네이티브 코드로 캐싱하여 재사용 속도를 높인다. JVM의 실행 속도를 높이는 내부 최적화 공간이다. 개발자가 직접 접근할 일은 거의 없다. 설정 옵션은 -XX:ReservedCodeCacheSize이다. Native Method Stack Java 코드가 JNI(Java Native Interface)를 통해 C/C++ 등 네이티브 함수를 호출할 때 사용되는 스택이다. Java 스택과 별도로 존재하며, 네이티브 메서드 호출 시마다 새로운 프레임이 생성된다. OS 종속적 구조이며, JVM 구현체마다 세부 동작이 다를 수 있다. 오버플로우가 발생하면 네이티브 레벨의 스택 오류가 발생할 수 있다. 하지만 객체의 생명주기를 프로그래머가 일일이 관리하기 어렵다는 문제가 발생하는데 Java는 메모리를 직접 제어하지 않고, 이 과정을 JVM 내부의 자동 메모리 관리 시스템, 즉 가비지 컬렉터(Garbage Collector)에게 맡겼다. GC는 더 이상 참조되지 않는 객체를 주기적으로 찾아내어 Heap 메모리에서 제거하고, 그 공간을 재활용한다. 덕분에 개발자는 메모리 해제 시점을 신경 쓰지 않아도 되고, 예상치 못한 메모리 누수나 포인터 오류로부터 훨씬 자유로워졌다. GC(Garbage Collection)와 메모리 관리 [GC의 기본 원리] Java의 메모리 관리는 객체의 생명주기 추적에 기반한다. JVM은 Heap 영역을 세대(Generation) 별로 나누어, 객체의 생존 기간에 따라 다른 방식으로 관리한다. 이 방식을 Generational Garbage Collection이라 부른다. 생성 (Allocation): new 키워드로 객체를 생성하면, Young Generation(Eden 영역)에 저장된다. 대부분의 객체는 짧은 생명주기를 가지므로, Eden이 가득 차면 Minor GC가 수행되어 사용하지 않는 객체를 정리한다. 살아남은 객체는 Survivor(S0, S1) 영역으로 복사된다. 생존 (Reference 유지): GC 사이클이 반복될 때마다 살아남은 객체는 Survivor → Old Generation 으로 승격(Promotion)된다. 오래된 객체는 수명이 길다고 판단되기 때문에, 이후에는 Major(또는 Full) GC 시점에만 검사된다. 이 과정을 통해 GC는 대부분의 짧게 쓰였다 사라지는 객체를 빠르게 처리하고, 비용이 큰 Old 영역 스캔을 최소화한다. 소멸 (Collection): 더 이상 참조되지 않는 객체는 GC Root(스택, 정적 필드, JNI 참조 등)에서 도달할 수 없다고 판단되면 수거된다. 이때 메모리는 자동으로 회수되어 Heap 공간이 재활용된다. Old Generation에 쌓인 객체가 많아질 경우 Full GC가 발생하며, 모든 스레드가 일시 중단(Stop-the-World)된다. [Stop-the-World와 성능 이슈] 다만 GC가 완벽한 해결책은 아니다. 객체를 정리하는 동안 모든 스레드가 멈추는 Stop-the-World 현상이 발생하기 때문이다. 이 시간은 짧을수록 좋지만, 대규모 시스템에서는 수 밀리초의 지연도 장애나 성능저하로 이어질 수 있다. 그래서 Java는 G1, ZGC, Shenandoah 같은 저지연 GC 를 통해 멈춤 시간을 최소화하는 방향으로 발전해왔다. [GC 알고리즘 종류와 특징] 종류 특징 장점 단점 Serial GC 단일 스레드로 GC 수행 단순, 소규모 앱에 적합 멀티코어 활용 불가 Parallel GC 여러 스레드로 병렬 GC 수행 높은 스루풋 일시정지(STW)가 길 수 있음 G1 GC Heap을 Region으로 나눠 병렬/점진 수집 예측 가능한 짧은 STW 약간의 CPU 오버헤드 ZGC 거의 멈추지 않는 GC (STW &amp;amp;lt; 10ms 수준) 초저지연 서비스용 구현 복잡, 메모리 오버헤드 Shenandoah GC ZGC와 유사, Red Hat 주도 짧은 STW + 백그라운드 수집 CPU 자원 소비 큼 [GC 관련 주요 옵션] -Xms, -Xmx: 힙의 초기/최대 크기 설정 -XX:MaxGCPauseMillis: GC 일시정지 시간 목표 지정 -XX:+UseG1GC: G1 GC 활성화 -Xlog:gc*: GC 로그 출력 설정 [GC 로그 출력하기] GC 로그를 통해 서비스 지연 구간을 파악하거나 Old 영역의 증가 추세를 통해 메모리 누수 여부를 감지할 수 있고 Minor / Full GC 비율로 객체 생명주기를 진단할 수 있다. 다음 명령어를 통해 GC 로그를 확인할 수 있다. java &amp;amp;#34;-Xlog:gc* Main.java&amp;amp;#34; 간단한 Java 객체 생성 코드를 GC 로그와 함께 실행해보면 public class Main { public static void main(String[] args) { List&amp;amp;lt;byte[]&amp;amp;gt; list = new ArrayList&amp;amp;lt;&amp;amp;gt;(); for (int i = 0; i &amp;amp;lt; 1000; i++) { list.add(new byte[1024 * 1024]); // 1MB 객체 생성 if (i % 100 == 0) System.out.println(&amp;amp;#34;i = &amp;amp;#34; + i); } } } GC, 메모리 초기 설정 코드 실행 중 메모리 상태 변화 주요 로그 [0.217s][info][gc ] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 28M-&amp;amp;gt;24M(292M) 2.596ms 이 로그는 G1 GC의 동작을 보여주는 예시다. Pause Young은 Young 영역에서 발생한 Minor GC를 의미한다. 28M-&amp;amp;gt;24M(292M)은 GC 수행 전후의 Heap 사용량을 나타낸다. 전체 Heap은 292MB이며, GC 후 24MB만 사용 중임을 보여준다. 2.595ms는 Stop-the-World 로 인한 애플리케이션 정지 시간이다. GC 로그를 파일로 남기고 싶다면 다음과 같이 명령어를 실행하면 된다. java &amp;amp;#34;-Xlog:gc*:file=gc.log:uptime,level,tags&amp;amp;#34; Main.java 마치며 이번 글에서는 JVM이 어떻게 메모리를 관리하고, 그 위에서 Java 코드가 실행되는지를 단계별로 정리해보았다. 운영체제 위의 또 다른 실행 환경이라는 관점에서 JVM을 바라보니, “Java가 왜 안정적이고 일관된 언어인가”를 조금 더 명확히 이해할 수 있었다. Java를 메인으로 활용하는 개발자에게 JVM 이해는 선택이 아니라 운영 환경을 제어하기 위한 필수 기반 지식이라고 생각한다. Spring Boot 환경에서도 빈 주입, 프록시, 비동기 스레드 풀처럼 메모리와 밀접한 요소가 많기 때문에 JVM 옵션이나 GC 옵션에 따른 차이를 직접 비교해보는 실험도 다뤄볼 예정이다. [참고자료] https://tcpschool.com/java/java_intro_programming https://d2.naver.com/helloworld/1230 https://velog.io/@joosing/heap-memory-leak-issue-the-deductive-process-of-finding-the-cause "><div class=post-entry__inner><header class=entry-header><h2 class=entry-hint-parent>Java는 어떻게 실행될까 — JVM과 메모리의 동작원리</h2></header><div class=entry-content><p>등장 배경부터 메모리 구조, 가비지 컬렉션까지 종합적으로 살펴보자</p></div><footer class=entry-footer><span class=meta-categories><a class=meta-category href=/categories/java/>Java</a></span>&nbsp;&nbsp;&nbsp;&nbsp;<span title='2025-11-02 21:09:00 +0900 KST'>2025. 11. 02 21:09</span></footer></div><figure class=entry-cover><img loading=lazy srcset='https://potential1205.github.io/posts/2025/java-memory-structure-deep-dive/images/jvm-memory-structure_hu_bb259a84218f4dde.png 360w,https://potential1205.github.io/posts/2025/java-memory-structure-deep-dive/images/jvm-memory-structure_hu_7a9702ec5deb625a.png 480w,https://potential1205.github.io/posts/2025/java-memory-structure-deep-dive/images/jvm-memory-structure.png 705w' src=https://potential1205.github.io/posts/2025/java-memory-structure-deep-dive/images/jvm-memory-structure.png sizes="(min-width: 768px) 720px, 100vw" width=705 height=512 alt="Java Memory Structure Diagram"></figure><a class=entry-link aria-label="post link to Java는 어떻게 실행될까 — JVM과 메모리의 동작원리" href=https://potential1205.github.io/posts/2025/java-memory-structure-deep-dive/></a></article></div><script>(function(){var e,t,n,s,o,i,a,r,d,u,h,c=document.getElementById("post-list");if(!c)return;r=Array.prototype.slice.call(c.querySelectorAll(".post-entry")),s=document.querySelector(".page-footer"),t=document.getElementById("post-search-empty"),a=document.getElementById("header-search"),e=document.querySelector(".page-header h1"),i=e?e.textContent:"";function l(e){return e?e.toString().toLowerCase():""}function m(e){return(e||"").replace(/[&<>"']/g,function(e){return{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[e]})}if(d=new URLSearchParams(window.location.search),n=(d.get("q")||"").trim(),a&&(a.value=n),!n){r.forEach(function(e){e.hidden=!1,e.style.display=""}),t&&(t.hidden=!0),s&&(s.hidden=!1),e&&i&&(e.textContent=i);return}if(u=l(n),o=0,r.forEach(function(e){var t=l(e.getAttribute("data-search")||"");t.indexOf(u)!==-1?(e.hidden=!1,e.style.display="",o++):(e.hidden=!0,e.style.display="none")}),s&&(s.hidden=!0),h="“"+n+"”",e&&(e.textContent=h+" ("+o+"건)"),!t)return;o===0?(t.hidden=!1,t.innerHTML="검색 결과가 없습니다: “"+m(n)+"”"):t.hidden=!0})()</script></section><aside class="main__sidebar main__sidebar--right" aria-hidden=true></aside></main><footer class=footer><span>&copy; 2025 <a href=https://potential1205.github.io/>파브르의 개발 블로그</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>